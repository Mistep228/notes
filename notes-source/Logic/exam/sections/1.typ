#import "../template.typ":*



= Исчисление высказываний

#def[def:] *Предметный язык* ---  формализация мат. утверждений.

#def[def:] *Метаязык* (или язык исследователя) --- язык, которым пользуются для формирования математических утвреждений.

#def[def:] *Высказывание* --- строка, которая либо атомарное высказывание(то есть какая-то переменная), либо составное(составлено с помощью отрицания, дизъюнкции, конъюнкции или импликации из двух высказываний).

#def[def:] *Схема высказываний* --- высказывание, где мы можем использовать метапеременные (вместо которых можно подставлять что угодно)

#def[def:] *Язык исчисления высказываний* --- язык, порождаемый грамматикой высказываний.

#def[def:] *Оценка высказываний*  --- множество истинностных значений(множество $V ={И,Л}$) и функция оценки переменных. Все оценки составных высказываний рекурсивно задаются

#def[def:] $alpha$ - *тавтология* (общезначима), если $models alpha$ или по-другому, что $alpha$ истинна при всех оценках

#def[def:] $gamma_1, ..., gamma_n models alpha$ - *следствие*, то есть если данные $gamma$ выполнены, то $alpha$ выполнено

#def[def:] *Доказательством* назовем конечную последовательность $delta_1, ..., delta_n$, где каждое $delta_i$ либо аксиома, либо получаестя по правило Modus Ponens($alpha$, $alpha -> beta$ $=>$ $beta$)

В классической логике есть 10 аксиом, которые задаются схемами. Назовем эти аксиомы аксиомами исчисления высказываний.


#def[def:] *Доказательство формулы *$alpha$ --- такое доказательство, что $delta_n equiv alpha$. Тогда $alpha$ называется *доказуемой*.

#def[def:] *Вывод формулы из гипотез* $gamma_1, ..., gamma_n$ - в доказательстве можем использовать еще и гипотезы. Обозначается $gamma_1, dots, gamma_n tack.r alpha$


#def[def:] *Теория корректна*, если любое доказуемое утверждение общезначимо.

#def[def:] *Теория полна*, если любое общезначимое утверждение доказуемо.

#def[def:] *Теория противоречива*, если существует $alpha$ , такое что $ tack.r alpha \& not alpha$. Эквивалентно, что любая формула доказуема, или для некоторой $alpha$ имеет место $tack.r alpha$ и $tack.r not alpha$


#theorem(name:[Теорема о дедукции], body:[
  $Gamma, alpha tack.r beta <=> Gamma tack.r alpha -> beta$
],proof:[
Доказательство в левую сторону очевидно. Докажем,что из $Gamma, alpha tack.r beta$ следует $Gamma tack.r alpha -> beta$  


Пусть $Gamma,alpha tack.r beta$, т.е. существует вывод $D = (delta_1,dots,delta_m)$, где $delta_m = beta$. 

Построим вывод $alpha -> beta$ из $Gamma$ *индукцией по длине вывода* $D$.

*База:* очевидно

#text(weight: "bold")[Шаг индукции]: 

Предположим, для всех выводов длины $<= m$ утверждение верно. Рассмотрим вывод $D$ длины $m+1$:

$ delta_1,dots,delta_m,delta_(m+1)(=beta) $

По индукционному предположению, уже построены выводы $zeta_i$ из $Gamma$, такие что $zeta_i = alpha -> delta_i$ для $i=1,dots,m$.

Разберём возможные случаи для $delta_(m+1)$:

1. #text(weight: "bold")[$delta_(m+1)$ — аксиома или $delta_(m+1) in Gamma$]: Тогда $Gamma tack.r delta_(m+1)$

  Добавим к построенным $zeta_1,dots,zeta_m$ шаги: 
   $ delta_(m+1) -> (alpha -> delta_(m+1)) "(акс.1)" $ 
   $ delta_(m+1) $
   $ alpha -> delta_(m+1) "(MP)" $

2. $delta_(m+1) equiv alpha$, $alpha -> alpha$ выводимо всегда

3. $delta_(m+1)$ получен по MP из $delta_j$ и $delta_k$ ($delta_k equiv delta_j -> delta_(m+1)$), где $j,k<m+1$ : 

  По индукционному предположению уже имеем $Gamma tack.r alpha -> delta_j$ и $Gamma tack.r alpha -> (delta_j -> delta_(m+1))$. 

  По акс.2:
   $( alpha -> delta_j) -> (alpha -> (delta_j -> delta_(m+1))) -> (alpha -> delta_(m+1) )$
   
   Применив MP дважды, получаем $ Gamma tack.r alpha -> delta_(m+1) $

Таким образом, во всех случаях $Gamma tack.r alpha -> delta_(m+1)$, т.е. $Gamma tack.r alpha -> beta$.

])