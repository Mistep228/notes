#import "../template.typ":*

= Функции

#def[def:] *Базовые примитивы *(исходные функции):
    -  Ноль (Z): Z(x) = 0.
    -   Инкремент (N): N(x) = x+1.
    -   Проекция (U): $U^k_n (x₁, ..., x_n) = x_k $(возвращает k-й аргумент).
    -   Подстановка (S): Если g — функция от k аргументов, а f₁, ..., fₖ — функции от n аргументов, то 
    
    $ S⟨g, f_1, ..., f_k⟩(x) = g(f_1 (x), ..., f_k (x)) $

#def[def:] *Примитивная рекурсия*.   Если f — функция от n аргументов, а g — функция от n+2 аргументов, то функция h = R⟨f, g⟩ от n+1 аргумента определяется так:
    -   h(x, 0) = f(x)
    -   h(x, y+1) = g(x, y, h(x, y))

#def[def:] *Примитивно-рекурсивная функция* --- функция, которую можно получить из базовых примитивов (Z, N, U) с помощью конечного числа применений операций подстановки (S) и примитивной рекурсии (R).


#def[def:] *Операция минимизации* (M): Если f — функция от n+1 аргумента, то $M⟨f⟩(x) = min{y | f(x, y) = 0}$, при условии, что такое y существует. Если для всех y значение $f(x, y) > 0$, то M⟨f⟩(x) не определено.

#def[def:]  *Общерекурсивная  функция* --- Функция, которую можно получить из базовых примитивов с помощью конечного числа применений операций подстановки (S), примитивной рекурсии (R) и минимизации (M).

#lemma(body:[
  Функция Аккермана не выражена в примитивно рекурсивных.

  $ A(m,n) = cases(n+1\,m=0, A(m-1,1)\,m>0\,n=0, A(m-1,A(m,n-1))), m>0,n>0 $
],proof:[
  Для этого докажем немного другую теорему. 
])

#theorem(title:[], body:[
  Пусть $f(x)$ - примитивно рекурсивная. Тогда найдется $k$, что $f(x)<A(k, max(x))$
], proof:[
Индукция по структуре f.
])

#def[def:] Будем говорить, что отношение $R subset.eq NN_0^n$ *выразимо в ФА*, если существует формула $rho$, что:
- если $⟨ a_1,dots,a_n ⟩ in R$, то $tack.r rho(a_1,dots,a_n)$
- если $⟨ a_1,dots,a_n ⟩ in. not R$, то $tack.r not rho(a_1,dots,a_n)$

#theorem(body:[
  Отношение "равно" выразимо в Ф.а.: $r = {chevron.l x,x chevron.r | x in NN_0}$
])

#def[def:] Будем говорить, что функция $f: NN_0^n -> NN_0$ *представима в ФА*, если существует формула $phi$, что:
- если $f(a_1, ...,a_n) = u$, то $tack.r phi(a_1,..., a_n,u)$
- если $f(a_1, ...,a_n) eq.not u$, то $tack.r not phi(a_1,..., a_n,u)$
- для всех $a_i in NN_0$ выполнено $tack.r (exists x. phi(a_1, ... , a_n,x)) \& (forall p,forall q, phi(a_1, ...,a_n, p) \& phi(a_1, ...,a_n, q) -> p = q)$

#def[def:] Для отношения R его *характеристическая функция* $χ_R$ возвращает 1, если аргумент принадлежит R, и 0 иначе. Отношение выразимо тогда и только тогда, когда представима его характеристическая функция.